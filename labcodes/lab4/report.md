1. 分配并初始化一个进程控制块
实现过程
  (1)根据相应要求初始化分配到的proc的成员变量。基本上是置为0和NULL，特例有state(PROC_UNINIT)、pid(-1)、cr3(boot_cr3)
请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是？
  context：保存寄存器内容，确保进程返回时可以还原现场
  tf：指向该进程的陷入帧，在进程返回之后可以用来回到进程之前的状态。

2. 为新创建的内核线程分配资源
实现过程
  (1)为新的线程分配一个proc_struct，失败则返回
  (2)设置当前进程为新线程的父线程
  (3)为新线程分配一个内核栈
  (4)赋予新线程以当前进程的内存管理信息
  (5)建立新线程的context与trapframe
  (6)将新线程的proc_struct插入哈希表与进程列表
  (7)唤醒新线程，使之可运行(RUNNABLE)
  (8)返回新线程的pid
请说明ucore是否做到给每个新fork的线程一个唯一的id？
  为新线程赋予id的工作由get_pid完成。根据其代码，它会在每次创建新线程时自增1并查询重复序号和补救。鉴于ucore的MAX_PROCESS为4096，在正常使用下可以认为每个线程拥有唯一的pid。

3.阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的
切换过程
  (1)检查要切换到的进程是否为当前进程，若是则无需做任何事，返回。
  (2)关闭中断
  (3)设置要切换到的进程为当前进程
  (4)将esp0寄存器的值压入要切换到的进程的内核栈的相应位置
  (5)将cr3寄存器的值赋给要切换到的进程的cr3变量中
  (6)根据当前进程（其实已经是上一个进程了）和要切换到的进程的上下文（context）进行切换。
  (7)打开中断
在本实验的执行过程中，创建且运行了几个内核线程？
  两个，idle和init。
语句local_intr_save(intr_flag);....local_intr_restore(intr_flag);在这里有何作用?
  这两个语句，一个关闭中断一个打开中断，它们负责让其间的代码在运行时不会被中断打断而造成错误。