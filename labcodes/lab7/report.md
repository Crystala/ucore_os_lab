1. 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题
给出内核级信号量的设计描述，并说其大致执行流流程。
  当多个（>1）进程可以进行互斥或同步合作时，一个进程会由于无法满足信号量设置的某条件而在某一位置停止，直到它接收到一个特定的信号（表明条件满足了）。
  信号量（一个计数器）用于发出信号。为通过信号量s传送信号，信号量通过V操作使得信号量的值减少，但如果信号量的值已经不大于0了，则down操作会使得进程陷入等待状态之中；为通过信号量s接收信号，信号量的P操作使得信号量的值增加，但是如果信号量的值已大于0并且有进程在等待队列中，则进程会被立即唤醒。
给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。
  内核态进程可以直接调用up/down方法，但用户态进程无法做到。内核态线程down执行时，如果线程陷入等待，则线程的状态被置为waiting，然后重新触发进程调度；用户态进程需要用系统调用来访问信号量，在down执行时应当根据信号量是否有空闲决定系统调用是否立即返回原线程。

2. 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题
  cond_wait:
    (1) 线程进入休眠状态
    (2) 唤醒其他进程。若有因执行cond_signal唤醒其它线程而自己陷入睡眠的线程，将其唤醒；否则唤醒一个因为管程互斥体对象而不能执行的线程
  cond_signal:
    (1)若发现没有进程正在等待条件变量，则恢复执行；否则会唤醒正在等待的进程，并进入等待状态。
  用户态条件变量和内核态条件变量的区别，主要是因为用户态的保护机制：一般不允许程序直接访问内核态管程结构体。故相关操作必须通过系统调用完成，令进程的等待和唤醒间的实际操作存在差异。
